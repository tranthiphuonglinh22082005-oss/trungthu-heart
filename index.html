<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<title>Trái tim Trung Thu Pháo Hoa</title>
<style>
body { margin:0; overflow:hidden; background:#000; }
canvas { display:block; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.156.0/build/three.min.js"></script>
<script>
// --- Scene & Camera ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.z = 130;

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// --- Tạo hạt trái tim ---
function createHeartParticles(){
    const particles = [];
    const step = 0.012;
    for(let s=-Math.PI;s<Math.PI;s+=step){
        for(let r=0;r<14;r+=0.3){
            const x = (16 - r) * Math.pow(Math.sin(s),3);
            const y = (13 - r/2)*Math.cos(s) -5*Math.cos(2*s)-2*Math.cos(3*s)-Math.cos(4*s);
            const z = (Math.random()-0.5)*1.2;
            const chance = r<3 ? 0.9 : 0.7*(1 - (y+20)/40);
            if(Math.random() < chance){
                particles.push(new THREE.Vector3(x*3, y*3 + 20, z*3)); // cao hơn
            }
        }
    }
    return particles;
}

let heartParticles = createHeartParticles();
let heartGeometry = new THREE.BufferGeometry().setFromPoints(heartParticles);
const colors = [];
heartParticles.forEach(p=>{
    const color = new THREE.Color().setHSL(Math.random(), 1, 0.6);
    colors.push(color.r,color.g,color.b);
});
heartGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors,3));
const heartMaterial = new THREE.PointsMaterial({vertexColors:true,size:0.3});
const heart = new THREE.Points(heartGeometry,heartMaterial);
scene.add(heart);

// --- Không bắn pháo hoa ra ngoài nữa ---
const fireworks = heartParticles.map(p=>({
    position: p.clone(),
    velocity: new THREE.Vector3(
        (Math.random()-0.5)*0.2,
        (Math.random()-0.5)*0.2,
        (Math.random()-0.5)*0.2
    )
}));

const fireGeom = new THREE.BufferGeometry().setFromPoints(fireworks.map(f=>f.position));
const fireMat = new THREE.PointsMaterial({vertexColors:false, color:0xffffff, size:0.25});
const firePoints = new THREE.Points(fireGeom,fireMat);
scene.add(firePoints);

// --- Chữ xoay ---
function createTextSprite(message,color){
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 64;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = color;
    ctx.font = "40px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(message, canvas.width/2, canvas.height/2);
    const texture = new THREE.CanvasTexture(canvas);
    const material = new THREE.SpriteMaterial({map:texture});
    const sprite = new THREE.Sprite(material);
    sprite.scale.set(18,4.5,1);
    return sprite;
}

const groups = [];
const radii = [55,65,75];
const colorsText = ['#FFD700','#FF69B4','#00FFFF'];
radii.forEach((radius,idx)=>{
    const group = new THREE.Group();
    const text = "TRUNG THU VUI VẺ ";
    for(let i=0;i<text.length;i++){
        const sprite = createTextSprite(text[i],colorsText[idx]);
        const angle = i/text.length * Math.PI*2;
        sprite.position.set(radius*Math.cos(angle), 0, radius*Math.sin(angle));
        sprite.lookAt(0,0,0);
        group.add(sprite);
    }
    group.position.y = -30; // thấp xuống dưới trái tim
    scene.add(group);
    groups.push({group:group,speed: idx%2===0?0.002:-0.002});
});

// --- Animation ---
const clock = new THREE.Clock();

function animate(){
    requestAnimationFrame(animate);
    const time = clock.getElapsedTime();

    // Trái tim đập nhịp
    const scale = 1 + 0.08*Math.sin(time*4);
    heart.scale.set(scale,scale,scale);

    // Hạt chuyển động nhẹ, không bay ra xa
    fireworks.forEach(f=>{
        f.position.add(f.velocity);
        if(f.position.length() > 120){
            f.position.multiplyScalar(0.9);
        }
    });
    fireGeom.setFromPoints(fireworks.map(f=>f.position));
    fireGeom.attributes.position.needsUpdate = true;

    // Chữ xoay quanh trái tim
    groups.forEach(g=>g.group.rotation.y += g.speed);

    renderer.render(scene,camera);
}

animate();
</script>
</body>
</html>
